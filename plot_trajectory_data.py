#!/usr/bin/env python3
"""
Independent trajectory data visualization program

This program is specifically designed to read .npz data files generated by run_controller.py 
and create detailed visualization charts. By separating visualization from the controller, 
it avoids affecting the real-time performance of the controller.

Usage:
1. Basic usage: python3 plot_trajectory_data.py
2. Specify file: python3 plot_trajectory_data.py --file path/to/data.npz
3. Batch processing: python3 plot_trajectory_data.py --batch
4. Comparison analysis: python3 plot_trajectory_data.py --compare file1.npz file2.npz

Author: Assistant
Date: 2025-01-16
"""

import numpy as np
import matplotlib.pyplot as plt
import argparse
import os
import glob
import time
from datetime import datetime

class TrajectoryDataPlotter:
    def __init__(self):
        self.base_results_dir = os.path.join(os.path.dirname(__file__), 'results', 'catch_test')
        # self.results_dir = os.path.join(self.base_results_dir, 'catch_test')
        
    def load_data(self, filepath):
        """Load trajectory data file"""
        try:
            data = np.load(filepath, allow_pickle=True)
            
            # Extract metadata
            metadata = data.get('metadata', {})
            if isinstance(metadata, np.ndarray):
                metadata = metadata.item()
                
            print(f"\nLoading data file: {os.path.basename(filepath)}")
            print(f"Robot: {metadata.get('robot_name', 'Unknown')}")
            print(f"Trajectory: {metadata.get('trajectory_name', 'Unknown')}")
            print(f"Duration: {metadata.get('recording_duration', 0):.2f} seconds")
            print(f"Number of samples: {metadata.get('num_samples', 0)}")
            print(f"Control frequency: {metadata.get('control_rate', 0)} Hz")
            
            return data, metadata
            
        except Exception as e:
            print(f"Failed to load data: {e}")
            return None, None
    
    def plot_position_velocity_tracking(self, data, metadata, save_path=None):
        """Plot position and velocity tracking charts"""
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - {traj_name} Position and Velocity Tracking Results', fontsize=16)
        
        # Position tracking
        position_labels = ['X Position', 'Y Position', 'Z Position']
        for i in range(3):
            axes[0, i].plot(time_data, position_data[:, i], 'b-', label='Actual', linewidth=2)
            axes[0, i].plot(time_data, ref_position_data[:, i], 'r--', label='Reference', linewidth=2)
            axes[0, i].set_xlabel('Time (s)')
            axes[0, i].set_ylabel(f'{position_labels[i]} (m)')
            axes[0, i].legend()
            axes[0, i].grid(True)
            axes[0, i].set_title(f'{position_labels[i]} Tracking')
        
        # Velocity tracking
        velocity_labels = ['X Velocity', 'Y Velocity', 'Z Velocity']
        for i in range(3):
            axes[1, i].plot(time_data, velocity_data[:, i], 'b-', label='Actual', linewidth=2)
            axes[1, i].plot(time_data, ref_velocity_data[:, i], 'r--', label='Reference', linewidth=2)
            axes[1, i].set_xlabel('Time (s)')
            axes[1, i].set_ylabel(f'{velocity_labels[i]} (m/s)')
            axes[1, i].legend()
            axes[1, i].grid(True)
            axes[1, i].set_title(f'{velocity_labels[i]} Tracking')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"1_position_velocity.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Position and velocity tracking plot saved to: {full_path}")
        
        return fig
    
    def plot_arm_joints(self, data, metadata, save_path=None):
        """Plot arm joint charts"""
        if 'arm_joint_positions' not in data or len(data['arm_joint_positions']) == 0:
            print("No arm data available, skipping arm joint plot generation")
            return None
            
        time_data = data['time']
        arm_pos_data = data['arm_joint_positions']
        arm_vel_data = data['arm_joint_velocities']
        ref_arm_pos_data = data['reference_arm_positions']
        
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Arm Joint Tracking Results', fontsize=16)
        
        # Joint 1 position
        axes[0, 0].plot(time_data, arm_pos_data[:, 0], 'b-', label='Actual Joint 1', linewidth=2)
        axes[0, 0].plot(time_data, ref_arm_pos_data[:, 0], 'r--', label='Reference Joint 1', linewidth=2)
        axes[0, 0].set_xlabel('Time (s)')
        axes[0, 0].set_ylabel('Joint 1 Position (rad)')
        axes[0, 0].legend()
        axes[0, 0].grid(True)
        axes[0, 0].set_title('Joint 1 Position Tracking')
        
        # Joint 2 position
        axes[0, 1].plot(time_data, arm_pos_data[:, 1], 'b-', label='Actual Joint 2', linewidth=2)
        axes[0, 1].plot(time_data, ref_arm_pos_data[:, 1], 'r--', label='Reference Joint 2', linewidth=2)
        axes[0, 1].set_xlabel('Time (s)')
        axes[0, 1].set_ylabel('Joint 2 Position (rad)')
        axes[0, 1].legend()
        axes[0, 1].grid(True)
        axes[0, 1].set_title('Joint 2 Position Tracking')
        
        # Joint velocities
        axes[1, 0].plot(time_data, arm_vel_data[:, 0], 'g-', label='Joint 1 Velocity', linewidth=2)
        axes[1, 0].set_xlabel('Time (s)')
        axes[1, 0].set_ylabel('Joint 1 Velocity (rad/s)')
        axes[1, 0].legend()
        axes[1, 0].grid(True)
        axes[1, 0].set_title('Joint 1 Velocity')
        
        axes[1, 1].plot(time_data, arm_vel_data[:, 1], 'g-', label='Joint 2 Velocity', linewidth=2)
        axes[1, 1].set_xlabel('Time (s)')
        axes[1, 1].set_ylabel('Joint 2 Velocity (rad/s)')
        axes[1, 1].legend()
        axes[1, 1].grid(True)
        axes[1, 1].set_title('Joint 2 Velocity')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"2_arm_joints.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Arm joint plot saved to: {full_path}")
        
        return fig
    
    def plot_mpc_performance(self, data, metadata, save_path=None):
        """Plot MPC performance charts"""
        time_data = data['time']
        mpc_times = data['mpc_solve_time'] * 1000  # Convert to milliseconds
        mpc_costs = data['mpc_cost']
        
        fig, axes = plt.subplots(2, 1, figsize=(10, 8))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - MPC Performance Analysis', fontsize=16)
        
        # MPC solve time
        axes[0].plot(time_data, mpc_times, 'b-', linewidth=2)
        axes[0].set_xlabel('Time (s)')
        axes[0].set_ylabel('MPC Solve Time (ms)')
        axes[0].grid(True)
        axes[0].set_title(f'MPC Solve Time (Average: {np.mean(mpc_times):.2f}ms, Max: {np.max(mpc_times):.2f}ms)')
        
        # Add solve time statistics
        axes[0].axhline(y=np.mean(mpc_times), color='r', linestyle='--', alpha=0.7, label=f'Average: {np.mean(mpc_times):.2f}ms')
        axes[0].axhline(y=np.percentile(mpc_times, 95), color='orange', linestyle='--', alpha=0.7, label=f'95th percentile: {np.percentile(mpc_times, 95):.2f}ms')
        axes[0].legend()
        
        # MPC cost function
        axes[1].plot(time_data, mpc_costs, 'r-', linewidth=2)
        axes[1].set_xlabel('Time (s)')
        axes[1].set_ylabel('MPC Cost')
        axes[1].grid(True)
        axes[1].set_title(f'MPC Cost Function (Average: {np.mean(mpc_costs):.3f}, Final: {mpc_costs[-1]:.3f})')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"3_mpc_performance.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"MPC performance plot saved to: {full_path}")
        
        return fig
    
    def plot_3d_trajectory(self, data, metadata, save_path=None):
        """Plot 3D trajectory"""
        position_data = data['position']
        ref_position_data = data['reference_position']
        
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        # Plot trajectories
        ax.plot(position_data[:, 0], position_data[:, 1], position_data[:, 2], 
                'b-', label='Actual Trajectory', linewidth=3, alpha=0.8)
        ax.plot(ref_position_data[:, 0], ref_position_data[:, 1], ref_position_data[:, 2], 
                'r--', label='Reference Trajectory', linewidth=3, alpha=0.8)
        
        # Mark start and end points
        ax.scatter(position_data[0, 0], position_data[0, 1], position_data[0, 2], 
                  color='green', s=100, label='Start')
        ax.scatter(position_data[-1, 0], position_data[-1, 1], position_data[-1, 2], 
                  color='red', s=100, label='End')
        
        ax.set_xlabel('X Position (m)')
        ax.set_ylabel('Y Position (m)')
        ax.set_zlabel('Z Position (m)')
        ax.set_ylim(-1.0, 1.0)
        ax.legend()
        
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        ax.set_title(f'{robot_name} - {traj_name} 3D Trajectory')
        
        if save_path:
            filename = f"4_trajectory_3d.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"3D trajectory plot saved to: {full_path}")
        
        return fig
    
    def plot_tracking_errors(self, data, metadata, save_path=None):
        """Plot tracking error analysis"""
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        # Calculate errors
        pos_error = np.linalg.norm(position_data - ref_position_data, axis=1)
        vel_error = np.linalg.norm(velocity_data - ref_velocity_data, axis=1)
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Tracking Error Analysis', fontsize=16)
        
        # Position error time series
        axes[0, 0].plot(time_data, pos_error, 'b-', linewidth=2)
        axes[0, 0].set_xlabel('Time (s)')
        axes[0, 0].set_ylabel('Position Error (m)')
        axes[0, 0].grid(True)
        axes[0, 0].set_title(f'Position Tracking Error (RMS: {np.sqrt(np.mean(pos_error**2)):.4f}m)')
        
        # Velocity error time series
        axes[0, 1].plot(time_data, vel_error, 'r-', linewidth=2)
        axes[0, 1].set_xlabel('Time (s)')
        axes[0, 1].set_ylabel('Velocity Error (m/s)')
        axes[0, 1].grid(True)
        axes[0, 1].set_title(f'Velocity Tracking Error (RMS: {np.sqrt(np.mean(vel_error**2)):.4f}m/s)')
        
        # Position error histogram
        axes[1, 0].hist(pos_error, bins=30, alpha=0.7, color='blue', edgecolor='black')
        axes[1, 0].axvline(np.mean(pos_error), color='red', linestyle='--', 
                          label=f'Mean: {np.mean(pos_error):.4f}m')
        axes[1, 0].axvline(np.percentile(pos_error, 95), color='orange', linestyle='--', 
                          label=f'95th percentile: {np.percentile(pos_error, 95):.4f}m')
        axes[1, 0].set_xlabel('Position Error (m)')
        axes[1, 0].set_ylabel('Frequency')
        axes[1, 0].set_title('Position Error Distribution')
        axes[1, 0].legend()
        axes[1, 0].grid(True, alpha=0.3)
        
        # Velocity error histogram
        axes[1, 1].hist(vel_error, bins=30, alpha=0.7, color='red', edgecolor='black')
        axes[1, 1].axvline(np.mean(vel_error), color='blue', linestyle='--', 
                          label=f'Mean: {np.mean(vel_error):.4f}m/s')
        axes[1, 1].axvline(np.percentile(vel_error, 95), color='orange', linestyle='--', 
                          label=f'95th percentile: {np.percentile(vel_error, 95):.4f}m/s')
        axes[1, 1].set_xlabel('Velocity Error (m/s)')
        axes[1, 1].set_ylabel('Frequency')
        axes[1, 1].set_title('Velocity Error Distribution')
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"5_tracking_error.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Tracking error analysis plot saved to: {full_path}")
        
        return fig
    
    def plot_control_commands(self, data, metadata, save_path=None):
        """Plot control command charts"""
        time_data = data['time']
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Control Command Analysis', fontsize=16)
        
        # MPC control commands (forces and moments)
        if 'mpc_control_ft' in data and len(data['mpc_control_ft']) > 0:
            mpc_control = np.array(data['mpc_control_ft'])
            
            # Force commands
            axes[0, 0].plot(time_data, mpc_control[:, 0], 'r-', label='Fx', linewidth=2)
            axes[0, 0].plot(time_data, mpc_control[:, 1], 'g-', label='Fy', linewidth=2)
            axes[0, 0].plot(time_data, mpc_control[:, 2], 'b-', label='Fz', linewidth=2)
            axes[0, 0].set_xlabel('Time (s)')
            axes[0, 0].set_ylabel('Force (N)')
            axes[0, 0].set_title('MPC Force Commands')
            axes[0, 0].legend()
            axes[0, 0].grid(True)
            
            # Moment commands
            axes[0, 1].plot(time_data, mpc_control[:, 3], 'r-', label='Mx', linewidth=2)
            axes[0, 1].plot(time_data, mpc_control[:, 4], 'g-', label='My', linewidth=2)
            axes[0, 1].plot(time_data, mpc_control[:, 5], 'b-', label='Mz', linewidth=2)
            axes[0, 1].set_xlabel('Time (s)')
            axes[0, 1].set_ylabel('Moment (N·m)')
            axes[0, 1].set_title('MPC Moment Commands')
            axes[0, 1].legend()
            axes[0, 1].grid(True)
        
        # L1 adaptive control commands
        if 'l1_control_ad' in data and len(data['l1_control_ad']) > 0:
            l1_control = np.array(data['l1_control_ad'])
            
            # L1 adaptive force commands
            axes[1, 0].plot(time_data, l1_control[:, 0], 'r-', label='L1 Fx', linewidth=2)
            axes[1, 0].plot(time_data, l1_control[:, 1], 'g-', label='L1 Fy', linewidth=2)
            axes[1, 0].plot(time_data, l1_control[:, 2], 'b-', label='L1 Fz', linewidth=2)
            axes[1, 0].set_xlabel('Time (s)')
            axes[1, 0].set_ylabel('L1 Adaptive Force (N)')
            axes[1, 0].set_title('L1 Adaptive Force Commands')
            axes[1, 0].legend()
            axes[1, 0].grid(True)
            
            # L1 adaptive moment commands
            axes[1, 1].plot(time_data, l1_control[:, 3], 'r-', label='L1 Mx', linewidth=2)
            axes[1, 1].plot(time_data, l1_control[:, 4], 'g-', label='L1 My', linewidth=2)
            axes[1, 1].plot(time_data, l1_control[:, 5], 'b-', label='L1 Mz', linewidth=2)
            axes[1, 1].set_xlabel('Time (s)')
            axes[1, 1].set_ylabel('L1 Adaptive Moment (N·m)')
            axes[1, 1].set_title('L1 Adaptive Moment Commands')
            axes[1, 1].legend()
            axes[1, 1].grid(True)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"6_control_commands.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Control command plot saved to: {full_path}")
        
        return fig
    
    def plot_gripper_analysis(self, data, metadata, save_path=None):
        """Plot gripper position and tracking error analysis"""
        time_data = data['time']
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Gripper Analysis', fontsize=16)
        
        # Gripper position vs reference
        if 'gripper_position' in data and len(data['gripper_position']) > 0:
            gripper_pos = np.array(data['gripper_position'])
            
            # Plot actual gripper position components
            if gripper_pos.shape[1] == 3:  # 3D position [x, y, z]
                axes[0, 0].plot(time_data, gripper_pos[:, 0], 'b-', label='Actual X', linewidth=2)
                axes[0, 0].plot(time_data, gripper_pos[:, 1], 'g-', label='Actual Y', linewidth=2)
                axes[0, 0].plot(time_data, gripper_pos[:, 2], 'orange', label='Actual Z', linewidth=2)
            else:  # Fallback for 1D position (old format)
                axes[0, 0].plot(time_data, gripper_pos, 'b-', label='Gripper Position', linewidth=2)
            
            # Add reference gripper position if available
            if 'ref_gripper_position' in data and len(data['ref_gripper_position']) > 0:
                ref_gripper_pos = np.array(data['ref_gripper_position'])
                # Plot reference position components
                axes[0, 0].plot(time_data, ref_gripper_pos[:, 0], 'r--', label='Ref X', linewidth=2, alpha=0.7)
                axes[0, 0].plot(time_data, ref_gripper_pos[:, 1], 'g--', label='Ref Y', linewidth=2, alpha=0.7)
                axes[0, 0].plot(time_data, ref_gripper_pos[:, 2], 'orange', linestyle='--', label='Ref Z', linewidth=2, alpha=0.7)
            
            axes[0, 0].set_xlabel('Time (s)')
            axes[0, 0].set_ylabel('Position (m)')
            axes[0, 0].set_title('Gripper Position vs Reference')
            axes[0, 0].legend()
            axes[0, 0].grid(True)
        
        # Gripper tracking error
        if 'gripper_tracking_error' in data and len(data['gripper_tracking_error']) > 0:
            gripper_error = np.array(data['gripper_tracking_error'])
            axes[0, 1].plot(time_data, gripper_error, 'r-', label='Tracking Error', linewidth=2)
            axes[0, 1].set_xlabel('Time (s)')
            axes[0, 1].set_ylabel('Error (m)')
            axes[0, 1].set_title('Gripper Tracking Error')
            axes[0, 1].legend()
            axes[0, 1].grid(True)
            
            # Add error statistics
            mean_error = np.mean(gripper_error)
            max_error = np.max(gripper_error)
            rms_error = np.sqrt(np.mean(gripper_error**2))
            axes[0, 1].axhline(y=mean_error, color='g', linestyle='--', alpha=0.7, label=f'Mean: {mean_error:.4f}m')
            axes[0, 1].axhline(y=max_error, color='orange', linestyle='--', alpha=0.7, label=f'Max: {max_error:.4f}m')
            axes[0, 1].legend()
        
        # Gripper pitch angle vs reference
        if 'gripper_pitch' in data and len(data['gripper_pitch']) > 0:
            gripper_pitch = np.array(data['gripper_pitch'])
            # Convert to degrees for better readability
            gripper_pitch_deg = np.degrees(gripper_pitch)
            axes[1, 0].plot(time_data, gripper_pitch_deg, 'b-', label='Actual Pitch', linewidth=2)
            
            # Add reference pitch angle if available
            if 'ref_gripper_pitch' in data and len(data['ref_gripper_pitch']) > 0:
                ref_gripper_pitch = np.array(data['ref_gripper_pitch'])
                ref_gripper_pitch_deg = np.degrees(ref_gripper_pitch)
                axes[1, 0].plot(time_data, ref_gripper_pitch_deg, 'r--', label='Reference Pitch', linewidth=2, alpha=0.7)
            
            axes[1, 0].set_xlabel('Time (s)')
            axes[1, 0].set_ylabel('Pitch Angle (degrees)')
            axes[1, 0].set_title('Gripper Pitch Angle vs Reference')
            axes[1, 0].legend()
            axes[1, 0].grid(True)
        
        # Gripper 3D trajectory comparison
        if 'ref_gripper_position' in data and len(data['ref_gripper_position']) > 0:
            ref_gripper_pos = np.array(data['ref_gripper_position'])
            
            # Plot 3D trajectory comparison
            axes[1, 1].plot(ref_gripper_pos[:, 0], ref_gripper_pos[:, 1], 'r--', label='Reference Trajectory', linewidth=2, alpha=0.7)
            
            # If we have actual gripper position from forward kinematics, plot it too
            # Note: This would require calculating actual gripper position from joint states
            # For now, we'll just show the reference trajectory in 2D (X-Y plane)
            
            axes[1, 1].set_xlabel('X Position (m)')
            axes[1, 1].set_ylabel('Y Position (m)')
            axes[1, 1].set_title('Gripper Trajectory (X-Y Plane)')
            axes[1, 1].legend()
            axes[1, 1].grid(True)
            axes[1, 1].axis('equal')  # Equal aspect ratio for better visualization
        
        plt.tight_layout()
        
        if save_path:
            filename = f"7_gripper_analysis.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Gripper analysis plot saved to: {full_path}")
        
        return fig
    
    def plot_drone_attitude_angular_velocity(self, data, metadata, save_path=None):
        """Plot drone attitude (Euler angles) and angular velocity tracking charts"""
        time_data = data['time']
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Drone Attitude and Angular Velocity Tracking', fontsize=16)
        
        # Convert quaternion to Euler angles for actual and reference
        if 'orientation' in data and len(data['orientation']) > 0:
            orientation_data = np.array(data['orientation'])
            ref_orientation_data = np.array(data['reference_orientation'])
            
            # Convert quaternions to Euler angles
            actual_euler = np.zeros((len(orientation_data), 3))
            ref_euler = np.zeros((len(ref_orientation_data), 3))
            
            for i in range(len(orientation_data)):
                # Convert quaternion to Euler angles (roll, pitch, yaw)
                actual_euler[i] = self.quaternion_to_euler(orientation_data[i])
                ref_euler[i] = self.quaternion_to_euler(ref_orientation_data[i])
            
            # Convert to degrees for better readability
            actual_euler_deg = np.degrees(actual_euler)
            ref_euler_deg = np.degrees(ref_euler)
            
            # Plot Euler angles
            euler_labels = ['Roll', 'Pitch', 'Yaw']
            for i in range(3):
                axes[0, i].plot(time_data, actual_euler_deg[:, i], 'b-', label='Actual', linewidth=2)
                axes[0, i].plot(time_data, ref_euler_deg[:, i], 'r--', label='Reference', linewidth=2)
                axes[0, i].set_xlabel('Time (s)')
                axes[0, i].set_ylabel(f'{euler_labels[i]} Angle (degrees)')
                axes[0, i].set_title(f'{euler_labels[i]} Angle Tracking')
                axes[0, i].legend()
                axes[0, i].grid(True)
        
        # Plot angular velocity
        if 'angular_velocity' in data and len(data['angular_velocity']) > 0:
            angular_vel_data = np.array(data['angular_velocity'])
            # Convert to degrees per second for better readability
            angular_vel_deg = np.degrees(angular_vel_data)
            
            angular_vel_labels = ['Roll Rate', 'Pitch Rate', 'Yaw Rate']
            for i in range(3):
                axes[1, i].plot(time_data, angular_vel_deg[:, i], 'g-', label='Actual', linewidth=2)
                axes[1, i].set_xlabel('Time (s)')
                axes[1, i].set_ylabel(f'{angular_vel_labels[i]} (deg/s)')
                axes[1, i].set_title(f'{angular_vel_labels[i]}')
                axes[1, i].legend()
                axes[1, i].grid(True)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"8_drone_attitude_angular_velocity.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Drone attitude and angular velocity plot saved to: {full_path}")
        
        return fig
    
    def quaternion_to_euler(self, quaternion):
        """Convert quaternion [x, y, z, w] to Euler angles [roll, pitch, yaw] in radians"""
        x, y, z, w = quaternion
        
        # Roll (x-axis rotation)
        sinr_cosp = 2 * (w * x + y * z)
        cosr_cosp = 1 - 2 * (x * x + y * y)
        roll = np.arctan2(sinr_cosp, cosr_cosp)
        
        # Pitch (y-axis rotation)
        sinp = 2 * (w * y - z * x)
        if abs(sinp) >= 1:
            pitch = np.copysign(np.pi / 2, sinp)  # use 90 degrees if out of range
        else:
            pitch = np.arcsin(sinp)
        
        # Yaw (z-axis rotation)
        siny_cosp = 2 * (w * z + x * y)
        cosy_cosp = 1 - 2 * (y * y + z * z)
        yaw = np.arctan2(siny_cosp, cosy_cosp)
        
        return np.array([roll, pitch, yaw])
    
    def plot_final_control_commands(self, data, metadata, save_path=None):
        """Plot final control commands: body rate, thrust, and arm joint commands"""
        time_data = data['time']
        
        fig, axes = plt.subplots(2, 2, figsize=(15, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Final Control Commands', fontsize=16)
        
        # Plot body rate commands
        if 'body_rate_commands' in data and len(data['body_rate_commands']) > 0:
            body_rate_data = np.array(data['body_rate_commands'])
            body_rate_deg = np.degrees(body_rate_data)  # Convert to degrees per second
            
            # Ensure time data and control data have same length
            min_length = min(len(time_data), len(body_rate_data))
            time_data_plot = time_data[:min_length]
            body_rate_deg_plot = body_rate_deg[:min_length]
            
            body_rate_labels = ['Roll Rate', 'Pitch Rate', 'Yaw Rate']
            for i in range(3):
                axes[0, 0].plot(time_data_plot, body_rate_deg_plot[:, i], label=body_rate_labels[i], linewidth=2)
            
            axes[0, 0].set_xlabel('Time (s)')
            axes[0, 0].set_ylabel('Body Rate (deg/s)')
            axes[0, 0].set_title('Body Rate Commands')
            axes[0, 0].legend()
            axes[0, 0].grid(True)
        
        # Plot thrust command
        if 'thrust_command' in data and len(data['thrust_command']) > 0:
            thrust_data = np.array(data['thrust_command'])
            # Ensure time data and thrust data have same length
            min_length_thrust = min(len(time_data), len(thrust_data))
            time_data_thrust = time_data[:min_length_thrust]
            thrust_data_plot = thrust_data[:min_length_thrust]
            
            axes[0, 1].plot(time_data_thrust, thrust_data_plot, 'r-', label='Thrust Command', linewidth=2)
            axes[0, 1].set_xlabel('Time (s)')
            axes[0, 1].set_ylabel('Thrust (0-1)')
            axes[0, 1].set_title('Thrust Command')
            axes[0, 1].legend()
            axes[0, 1].grid(True)
            axes[0, 1].set_ylim(0, 1)
        
        # Plot arm joint commands
        if 'arm_joint_commands' in data and len(data['arm_joint_commands']) > 0:
            arm_commands_data = np.array(data['arm_joint_commands'])
            arm_control_mode = metadata.get('arm_control_mode', 'Unknown')
            
            # Ensure time data and arm commands data have same length
            min_length_arm = min(len(time_data), len(arm_commands_data))
            time_data_arm = time_data[:min_length_arm]
            arm_commands_data_plot = arm_commands_data[:min_length_arm]
            
            if arm_control_mode == 'position':
                unit = 'rad'
                title_suffix = 'Position Commands'
            elif arm_control_mode == 'velocity':
                unit = 'rad/s'
                title_suffix = 'Velocity Commands'
            elif arm_control_mode == 'effort':
                unit = 'Nm'
                title_suffix = 'Effort Commands'
            else:
                unit = ''
                title_suffix = 'Commands'
            
            for i in range(arm_commands_data_plot.shape[1]):
                axes[1, 0].plot(time_data_arm, arm_commands_data_plot[:, i], label=f'Joint {i+1}', linewidth=2)
            
            axes[1, 0].set_xlabel('Time (s)')
            axes[1, 0].set_ylabel(f'Arm Joint {title_suffix} ({unit})')
            axes[1, 0].set_title(f'Arm Joint {title_suffix}')
            axes[1, 0].legend()
            axes[1, 0].grid(True)
        
        # Plot control command statistics
        if 'body_rate_commands' in data and len(data['body_rate_commands']) > 0:
            body_rate_data = np.array(data['body_rate_commands'])
            body_rate_abs = np.abs(body_rate_data)
            
            # Calculate statistics
            max_roll_rate = np.max(body_rate_abs[:, 0])
            max_pitch_rate = np.max(body_rate_abs[:, 1])
            max_yaw_rate = np.max(body_rate_abs[:, 2])
            mean_roll_rate = np.mean(body_rate_abs[:, 0])
            mean_pitch_rate = np.mean(body_rate_abs[:, 1])
            mean_yaw_rate = np.mean(body_rate_abs[:, 2])
            
            # Create bar chart for maximum values
            categories = ['Roll Rate', 'Pitch Rate', 'Yaw Rate']
            max_values = [max_roll_rate, max_pitch_rate, max_yaw_rate]
            mean_values = [mean_roll_rate, mean_pitch_rate, mean_yaw_rate]
            
            x = np.arange(len(categories))
            width = 0.35
            
            axes[1, 1].bar(x - width/2, np.degrees(max_values), width, label='Max (abs)', alpha=0.8)
            axes[1, 1].bar(x + width/2, np.degrees(mean_values), width, label='Mean (abs)', alpha=0.8)
            
            axes[1, 1].set_xlabel('Body Rate Components')
            axes[1, 1].set_ylabel('Angular Velocity (deg/s)')
            axes[1, 1].set_title('Body Rate Command Statistics')
            axes[1, 1].set_xticks(x)
            axes[1, 1].set_xticklabels(categories)
            axes[1, 1].legend()
            axes[1, 1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"9_final_control_commands.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Final control commands plot saved to: {full_path}")
        
        return fig
    
    def generate_comprehensive_report(self, data, metadata, save_path=None):
        """Generate comprehensive analysis report"""
        print("\n" + "="*60)
        print("TRAJECTORY EXECUTION COMPREHENSIVE ANALYSIS REPORT")
        print("="*60)
        
        # Basic information
        print(f"Robot name: {metadata.get('robot_name', 'Unknown')}")
        print(f"Trajectory name: {metadata.get('trajectory_name', 'Unknown')}")
        print(f"Control mode: {metadata.get('control_mode', 'Unknown')}")
        print(f"Arm enabled: {metadata.get('arm_enabled', False)}")
        print(f"Recording duration: {metadata.get('recording_duration', 0):.2f} seconds")
        print(f"Sampling frequency: {metadata.get('control_rate', 0)} Hz")
        print(f"Number of data points: {metadata.get('num_samples', 0)}")
        
        # Performance analysis
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        # Calculate tracking errors
        pos_error = np.linalg.norm(position_data - ref_position_data, axis=1)
        vel_error = np.linalg.norm(velocity_data - ref_velocity_data, axis=1)
        
        # Attitude analysis
        if 'orientation' in data and len(data['orientation']) > 0:
            orientation_data = np.array(data['orientation'])
            ref_orientation_data = np.array(data['reference_orientation'])
            
            # Convert quaternions to Euler angles
            actual_euler = np.zeros((len(orientation_data), 3))
            ref_euler = np.zeros((len(ref_orientation_data), 3))
            
            for i in range(len(orientation_data)):
                actual_euler[i] = self.quaternion_to_euler(orientation_data[i])
                ref_euler[i] = self.quaternion_to_euler(ref_orientation_data[i])
            
            # Calculate attitude tracking errors
            attitude_error = np.abs(actual_euler - ref_euler)
            attitude_error_deg = np.degrees(attitude_error)
            
            print(f"\nAttitude tracking performance:")
            print(f"  Roll error - Mean: {np.mean(attitude_error_deg[:, 0]):.2f}°, Max: {np.max(attitude_error_deg[:, 0]):.2f}°")
            print(f"  Pitch error - Mean: {np.mean(attitude_error_deg[:, 1]):.2f}°, Max: {np.max(attitude_error_deg[:, 1]):.2f}°")
            print(f"  Yaw error - Mean: {np.mean(attitude_error_deg[:, 2]):.2f}°, Max: {np.max(attitude_error_deg[:, 2]):.2f}°")
        
        # Angular velocity analysis
        if 'angular_velocity' in data and len(data['angular_velocity']) > 0:
            angular_vel_data = np.array(data['angular_velocity'])
            angular_vel_deg = np.degrees(angular_vel_data)
            
            print(f"\nAngular velocity performance:")
            print(f"  Roll rate - Mean: {np.mean(np.abs(angular_vel_deg[:, 0])):.2f}°/s, Max: {np.max(np.abs(angular_vel_deg[:, 0])):.2f}°/s")
            print(f"  Pitch rate - Mean: {np.mean(np.abs(angular_vel_deg[:, 1])):.2f}°/s, Max: {np.max(np.abs(angular_vel_deg[:, 1])):.2f}°/s")
            print(f"  Yaw rate - Mean: {np.mean(np.abs(angular_vel_deg[:, 2])):.2f}°/s, Max: {np.max(np.abs(angular_vel_deg[:, 2])):.2f}°/s")
        
        # Control command analysis
        if 'body_rate_commands' in data and len(data['body_rate_commands']) > 0:
            body_rate_data = np.array(data['body_rate_commands'])
            body_rate_deg = np.degrees(body_rate_data)
            
            print(f"\nControl command performance:")
            print(f"  Body rate commands - Roll: Max {np.max(np.abs(body_rate_deg[:, 0])):.2f}°/s, Mean {np.mean(np.abs(body_rate_deg[:, 0])):.2f}°/s")
            print(f"  Body rate commands - Pitch: Max {np.max(np.abs(body_rate_deg[:, 1])):.2f}°/s, Mean {np.mean(np.abs(body_rate_deg[:, 1])):.2f}°/s")
            print(f"  Body rate commands - Yaw: Max {np.max(np.abs(body_rate_deg[:, 2])):.2f}°/s, Mean {np.mean(np.abs(body_rate_deg[:, 2])):.2f}°/s")
        
        if 'thrust_command' in data and len(data['thrust_command']) > 0:
            thrust_data = np.array(data['thrust_command'])
            print(f"  Thrust command - Max: {np.max(thrust_data):.3f}, Mean: {np.mean(thrust_data):.3f}, Min: {np.min(thrust_data):.3f}")
        
        if 'arm_joint_commands' in data and len(data['arm_joint_commands']) > 0:
            arm_commands_data = np.array(data['arm_joint_commands'])
            arm_control_mode = metadata.get('arm_control_mode', 'Unknown')
            print(f"  Arm joint commands ({arm_control_mode} mode):")
            for i in range(arm_commands_data.shape[1]):
                print(f"    Joint {i+1} - Max: {np.max(np.abs(arm_commands_data[:, i])):.3f}, Mean: {np.mean(np.abs(arm_commands_data[:, i])):.3f}")
        
        print(f"\nPosition tracking performance:")
        print(f"  Mean error: {np.mean(pos_error):.4f} m")
        print(f"  Max error: {np.max(pos_error):.4f} m")
        print(f"  RMS error: {np.sqrt(np.mean(pos_error**2)):.4f} m")
        print(f"  Standard deviation: {np.std(pos_error):.4f} m")
        
        print(f"\nVelocity tracking performance:")
        print(f"  Mean error: {np.mean(vel_error):.4f} m/s")
        print(f"  Max error: {np.max(vel_error):.4f} m/s")
        print(f"  RMS error: {np.sqrt(np.mean(vel_error**2)):.4f} m/s")
        print(f"  Standard deviation: {np.std(vel_error):.4f} m/s")
        
        # MPC performance
        mpc_times = data['mpc_solve_time'] * 1000
        mpc_costs = data['mpc_cost']
        
        print(f"\nMPC controller performance:")
        print(f"  Mean solve time: {np.mean(mpc_times):.2f} ms")
        print(f"  Max solve time: {np.max(mpc_times):.2f} ms")
        print(f"  95th percentile solve time: {np.percentile(mpc_times, 95):.2f} ms")
        print(f"  Mean cost: {np.mean(mpc_costs):.3f}")
        print(f"  Final cost: {mpc_costs[-1]:.3f}")
        
        # Arm performance (if data available)
        if 'arm_joint_positions' in data and len(data['arm_joint_positions']) > 0:
            arm_pos_data = data['arm_joint_positions']
            arm_vel_data = data['arm_joint_velocities']
            ref_arm_pos_data = data['reference_arm_positions']
            
            arm_pos_error = np.linalg.norm(arm_pos_data - ref_arm_pos_data, axis=1)
            
            print(f"\nArm tracking performance:")
            print(f"  Mean joint position error: {np.mean(arm_pos_error):.4f} rad")
            print(f"  Max joint position error: {np.max(arm_pos_error):.4f} rad")
            print(f"  Joint 1 mean velocity: {np.mean(np.abs(arm_vel_data[:, 0])):.3f} rad/s")
            print(f"  Joint 2 mean velocity: {np.mean(np.abs(arm_vel_data[:, 1])):.3f} rad/s")
        
        # Gripper performance (if data available)
        if 'gripper_tracking_error' in data and len(data['gripper_tracking_error']) > 0:
            gripper_error = np.array(data['gripper_tracking_error'])
            
            print(f"\nGripper tracking performance:")
            print(f"  Mean tracking error: {np.mean(gripper_error):.4f} m")
            print(f"  Max tracking error: {np.max(gripper_error):.4f} m")
            print(f"  RMS tracking error: {np.sqrt(np.mean(gripper_error**2)):.4f} m")
            print(f"  Standard deviation: {np.std(gripper_error):.4f} m")
            
            # Gripper position statistics
            if 'gripper_position' in data and len(data['gripper_position']) > 0:
                gripper_pos = np.array(data['gripper_position'])
                if gripper_pos.shape[1] == 3:  # 3D position
                    print(f"  Gripper X position range: {np.min(gripper_pos[:, 0]):.3f} to {np.max(gripper_pos[:, 0]):.3f} m")
                    print(f"  Gripper Y position range: {np.min(gripper_pos[:, 1]):.3f} to {np.max(gripper_pos[:, 1]):.3f} m")
                    print(f"  Gripper Z position range: {np.min(gripper_pos[:, 2]):.3f} to {np.max(gripper_pos[:, 2]):.3f} m")
                    print(f"  Mean gripper position: [{np.mean(gripper_pos[:, 0]):.3f}, {np.mean(gripper_pos[:, 1]):.3f}, {np.mean(gripper_pos[:, 2]):.3f}] m")
                else:  # 1D position (old format)
                    print(f"  Gripper position range: {np.min(gripper_pos):.3f} to {np.max(gripper_pos):.3f} m")
                    print(f"  Mean gripper position: {np.mean(gripper_pos):.3f} m")
            
            # Gripper pitch angle statistics
            if 'gripper_pitch' in data and len(data['gripper_pitch']) > 0:
                gripper_pitch = np.array(data['gripper_pitch'])
                gripper_pitch_deg = np.degrees(gripper_pitch)
                print(f"  Gripper Pitch range: {np.min(gripper_pitch_deg):.1f} to {np.max(gripper_pitch_deg):.1f} degrees")
                print(f"  Mean gripper pitch: {np.mean(gripper_pitch_deg):.1f} degrees")
                
                # Reference pitch statistics
                if 'ref_gripper_pitch' in data and len(data['ref_gripper_pitch']) > 0:
                    ref_gripper_pitch = np.array(data['ref_gripper_pitch'])
                    ref_gripper_pitch_deg = np.degrees(ref_gripper_pitch)
                    print(f"  Reference Pitch range: {np.min(ref_gripper_pitch_deg):.1f} to {np.max(ref_gripper_pitch_deg):.1f} degrees")
                    print(f"  Mean reference pitch: {np.mean(ref_gripper_pitch_deg):.1f} degrees")
                    
                    # Pitch tracking error
                    pitch_error = np.abs(gripper_pitch_deg - ref_gripper_pitch_deg)
                    print(f"  Pitch tracking error - Mean: {np.mean(pitch_error):.1f} degrees, Max: {np.max(pitch_error):.1f} degrees")
        
        # Save report to file
        if save_path:
            robot_name = metadata.get('robot_name', 'Unknown')
            traj_name = metadata.get('trajectory_name', 'Unknown')
            report_filename = f"{robot_name}_{traj_name}_analysis_report_{time.strftime('%Y%m%d_%H%M%S')}.txt"
            report_path = os.path.join(save_path, report_filename)
            
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write("TRAJECTORY EXECUTION COMPREHENSIVE ANALYSIS REPORT\n")
                f.write("="*60 + "\n\n")
                f.write(f"Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                f.write("Basic Information:\n")
                f.write(f"  Robot name: {metadata.get('robot_name', 'Unknown')}\n")
                f.write(f"  Trajectory name: {metadata.get('trajectory_name', 'Unknown')}\n")
                f.write(f"  Control mode: {metadata.get('control_mode', 'Unknown')}\n")
                f.write(f"  Arm enabled: {metadata.get('arm_enabled', False)}\n")
                f.write(f"  Recording duration: {metadata.get('recording_duration', 0):.2f} seconds\n")
                f.write(f"  Sampling frequency: {metadata.get('control_rate', 0)} Hz\n")
                f.write(f"  Number of data points: {metadata.get('num_samples', 0)}\n\n")
                
                f.write("Position tracking performance:\n")
                f.write(f"  Mean error: {np.mean(pos_error):.4f} m\n")
                f.write(f"  Max error: {np.max(pos_error):.4f} m\n")
                f.write(f"  RMS error: {np.sqrt(np.mean(pos_error**2)):.4f} m\n")
                f.write(f"  Standard deviation: {np.std(pos_error):.4f} m\n\n")
                
                f.write("Velocity tracking performance:\n")
                f.write(f"  Mean error: {np.mean(vel_error):.4f} m/s\n")
                f.write(f"  Max error: {np.max(vel_error):.4f} m/s\n")
                f.write(f"  RMS error: {np.sqrt(np.mean(vel_error**2)):.4f} m/s\n")
                f.write(f"  Standard deviation: {np.std(vel_error):.4f} m/s\n\n")
                
                f.write("MPC controller performance:\n")
                f.write(f"  Mean solve time: {np.mean(mpc_times):.2f} ms\n")
                f.write(f"  Max solve time: {np.max(mpc_times):.2f} ms\n")
                f.write(f"  95th percentile solve time: {np.percentile(mpc_times, 95):.2f} ms\n")
                f.write(f"  Mean cost: {np.mean(mpc_costs):.3f}\n")
                f.write(f"  Final cost: {mpc_costs[-1]:.3f}\n\n")
            
            print(f"\nAnalysis report saved to: {report_path}")
    
    def find_latest_file(self, robot_name=None):
        """Find the latest data file"""
        if not os.path.exists(self.base_results_dir):
            print(f"Base results directory {self.base_results_dir} does not exist!")
            return None
        
        if robot_name:
            pattern = os.path.join(self.base_results_dir, "*", f"{robot_name}_*_trajectory_data*.npz")
        else:
            pattern = os.path.join(self.base_results_dir, "*", "*_trajectory_data.npz")
        
        files = glob.glob(pattern)
        
        if not files:
            print("No data files found")
            return None
        
        # Sort by modification time, newest first
        files.sort(key=os.path.getmtime, reverse=True)
        latest_file = files[0]
        
        return latest_file
    
    def find_all_files(self, robot_name=None):
        """Find all data files"""
        if not os.path.exists(self.results_dir):
            return []
        
        if robot_name:
            pattern = os.path.join(self.results_dir, f"{robot_name}_*_trajectory_data_*.npz")
        else:
            pattern = os.path.join(self.results_dir, "*_trajectory_data_*.npz")
        
        files = glob.glob(pattern)
        files.sort(key=os.path.getmtime, reverse=True)
        return files
    
    def process_single_file(self, filepath, show_plots=True, save_plots=True):
        """Process single data file"""
        print(f"\nProcessing file: {filepath}")
        
        # Update self.results_dir based on the folder containing the found file
        file_dir = os.path.dirname(filepath)
        self.results_dir = file_dir
        print(f"Updated results directory to: {self.results_dir}")
        
        # Load data
        data, metadata = self.load_data(filepath)
        if data is None:
            return
        
        save_path = self.results_dir if save_plots else None
        
        # Generate all plots
        print("\nGenerating plots...")
        
        figures = []
        
        # Position velocity tracking
        fig1 = self.plot_position_velocity_tracking(data, metadata, save_path)
        figures.append(fig1)
        
        # Arm joints (if data available)
        fig2 = self.plot_arm_joints(data, metadata, save_path)
        if fig2:
            figures.append(fig2)
        
        # MPC performance
        fig3 = self.plot_mpc_performance(data, metadata, save_path)
        figures.append(fig3)
        
        # 3D trajectory
        fig4 = self.plot_3d_trajectory(data, metadata, save_path)
        figures.append(fig4)
        
        # Tracking error analysis
        fig5 = self.plot_tracking_errors(data, metadata, save_path)
        figures.append(fig5)
        
        # Control commands
        fig6 = self.plot_control_commands(data, metadata, save_path)
        figures.append(fig6)
        
        # Gripper analysis
        fig7 = self.plot_gripper_analysis(data, metadata, save_path)
        figures.append(fig7)
        
        # Drone attitude and angular velocity
        fig8 = self.plot_drone_attitude_angular_velocity(data, metadata, save_path)
        figures.append(fig8)
        
        # Final control commands
        fig9 = self.plot_final_control_commands(data, metadata, save_path)
        figures.append(fig9)
        
        # Generate comprehensive report
        self.generate_comprehensive_report(data, metadata, save_path)
        
        if show_plots:
            plt.show()
        else:
            # Close all figures to free memory
            for fig in figures:
                if fig:
                    plt.close(fig)
    
    def process_batch(self, robot_name=None, show_plots=False):
        """Batch process all data files"""
        files = self.find_all_files(robot_name)
        
        if not files:
            print("No data files found")
            return
        
        print(f"Found {len(files)} data files, starting batch processing...")
        
        for i, filepath in enumerate(files):
            print(f"\n[{i+1}/{len(files)}] ", end="")
            self.process_single_file(filepath, show_plots=False, save_plots=True)
        
        print(f"\nBatch processing complete! Processed {len(files)} files")

def main():
    parser = argparse.ArgumentParser(description='Trajectory data visualization tool')
    parser.add_argument('--file', '-f', type=str, help='Specify data file path')
    parser.add_argument('--robot', '-r', type=str, help='Specify robot name')
    parser.add_argument('--batch', '-b', action='store_true', help='Batch process all files')
    parser.add_argument('--no-show', action='store_true', help='Do not show plots, only save')
    parser.add_argument('--compare', '-c', nargs='+', help='Compare multiple data files')
    
    args = parser.parse_args()
    
    plotter = TrajectoryDataPlotter()
    
    if args.compare:
        # Comparison mode
        print("Comparison analysis mode - feature to be implemented")
        # TODO: Implement comparison functionality
    elif args.batch:
        # Batch processing mode
        plotter.process_batch(args.robot, show_plots=not args.no_show)
    elif args.file:
        # Specified file mode
        if not os.path.exists(args.file):
            print(f"File does not exist: {args.file}")
            return
        plotter.process_single_file(args.file, show_plots=not args.no_show)
    else:
        # Default: process latest file
        latest_file = plotter.find_latest_file(args.robot)
        if latest_file:
            print(f"Processing latest file: {os.path.basename(latest_file)}")
            plotter.process_single_file(latest_file, show_plots=not args.no_show)
        else:
            print("No data files found")
            print("\nUsage instructions:")
            print("1. Basic usage (process latest file): python3 plot_trajectory_data.py")
            print("2. Specify file: python3 plot_trajectory_data.py --file path/to/data.npz")
            print("3. Batch processing: python3 plot_trajectory_data.py --batch")
            print("4. Specify robot: python3 plot_trajectory_data.py --robot s500_uam")
            print("5. No display mode: python3 plot_trajectory_data.py --no-show")

if __name__ == "__main__":
    main()
