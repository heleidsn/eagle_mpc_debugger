#!/usr/bin/env python3
"""
Independent trajectory data visualization program

This program is specifically designed to read .npz data files generated by run_controller.py 
and create detailed visualization charts. By separating visualization from the controller, 
it avoids affecting the real-time performance of the controller.

Usage:
1. Basic usage: python3 plot_trajectory_data.py
2. Specify file: python3 plot_trajectory_data.py --file path/to/data.npz
3. Batch processing: python3 plot_trajectory_data.py --batch
4. Comparison analysis: python3 plot_trajectory_data.py --compare file1.npz file2.npz

Author: Assistant
Date: 2025-01-16
"""

import numpy as np
import matplotlib.pyplot as plt
import argparse
import os
import glob
import time
from datetime import datetime

class TrajectoryDataPlotter:
    def __init__(self):
        self.base_results_dir = os.path.join(os.path.dirname(__file__), 'results', 'catch_test')
        # self.results_dir = os.path.join(self.base_results_dir, 'catch_test')
        
    def load_data(self, filepath):
        """Load trajectory data file"""
        try:
            data = np.load(filepath, allow_pickle=True)
            
            # Extract metadata
            metadata = data.get('metadata', {})
            if isinstance(metadata, np.ndarray):
                metadata = metadata.item()
                
            print(f"\nLoading data file: {os.path.basename(filepath)}")
            print(f"Robot: {metadata.get('robot_name', 'Unknown')}")
            print(f"Trajectory: {metadata.get('trajectory_name', 'Unknown')}")
            print(f"Duration: {metadata.get('recording_duration', 0):.2f} seconds")
            print(f"Number of samples: {metadata.get('num_samples', 0)}")
            print(f"Control frequency: {metadata.get('control_rate', 0)} Hz")
            
            return data, metadata
            
        except Exception as e:
            print(f"Failed to load data: {e}")
            return None, None
    
    def plot_position_velocity_tracking(self, data, metadata, save_path=None):
        """Plot position and velocity tracking charts"""
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        fig, axes = plt.subplots(2, 3, figsize=(15, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - {traj_name} Position and Velocity Tracking Results', fontsize=16)
        
        # Position tracking
        position_labels = ['X Position', 'Y Position', 'Z Position']
        for i in range(3):
            axes[0, i].plot(time_data, position_data[:, i], 'b-', label='Actual', linewidth=2)
            axes[0, i].plot(time_data, ref_position_data[:, i], 'r--', label='Reference', linewidth=2)
            axes[0, i].set_xlabel('Time (s)')
            axes[0, i].set_ylabel(f'{position_labels[i]} (m)')
            axes[0, i].legend()
            axes[0, i].grid(True)
            axes[0, i].set_title(f'{position_labels[i]} Tracking')
        
        # Velocity tracking
        velocity_labels = ['X Velocity', 'Y Velocity', 'Z Velocity']
        for i in range(3):
            axes[1, i].plot(time_data, velocity_data[:, i], 'b-', label='Actual', linewidth=2)
            axes[1, i].plot(time_data, ref_velocity_data[:, i], 'r--', label='Reference', linewidth=2)
            axes[1, i].set_xlabel('Time (s)')
            axes[1, i].set_ylabel(f'{velocity_labels[i]} (m/s)')
            axes[1, i].legend()
            axes[1, i].grid(True)
            axes[1, i].set_title(f'{velocity_labels[i]} Tracking')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"1_position_velocity.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Position and velocity tracking plot saved to: {full_path}")
        
        return fig
    
    def plot_arm_joints(self, data, metadata, save_path=None):
        """Plot arm joint charts"""
        if 'arm_joint_positions' not in data or len(data['arm_joint_positions']) == 0:
            print("No arm data available, skipping arm joint plot generation")
            return None
            
        time_data = data['time']
        arm_pos_data = data['arm_joint_positions']
        arm_vel_data = data['arm_joint_velocities']
        ref_arm_pos_data = data['reference_arm_positions']
        
        fig, axes = plt.subplots(2, 2, figsize=(12, 8))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Arm Joint Tracking Results', fontsize=16)
        
        # Joint 1 position
        axes[0, 0].plot(time_data, arm_pos_data[:, 0], 'b-', label='Actual Joint 1', linewidth=2)
        axes[0, 0].plot(time_data, ref_arm_pos_data[:, 0], 'r--', label='Reference Joint 1', linewidth=2)
        axes[0, 0].set_xlabel('Time (s)')
        axes[0, 0].set_ylabel('Joint 1 Position (rad)')
        axes[0, 0].legend()
        axes[0, 0].grid(True)
        axes[0, 0].set_title('Joint 1 Position Tracking')
        
        # Joint 2 position
        axes[0, 1].plot(time_data, arm_pos_data[:, 1], 'b-', label='Actual Joint 2', linewidth=2)
        axes[0, 1].plot(time_data, ref_arm_pos_data[:, 1], 'r--', label='Reference Joint 2', linewidth=2)
        axes[0, 1].set_xlabel('Time (s)')
        axes[0, 1].set_ylabel('Joint 2 Position (rad)')
        axes[0, 1].legend()
        axes[0, 1].grid(True)
        axes[0, 1].set_title('Joint 2 Position Tracking')
        
        # Joint velocities
        axes[1, 0].plot(time_data, arm_vel_data[:, 0], 'g-', label='Joint 1 Velocity', linewidth=2)
        axes[1, 0].set_xlabel('Time (s)')
        axes[1, 0].set_ylabel('Joint 1 Velocity (rad/s)')
        axes[1, 0].legend()
        axes[1, 0].grid(True)
        axes[1, 0].set_title('Joint 1 Velocity')
        
        axes[1, 1].plot(time_data, arm_vel_data[:, 1], 'g-', label='Joint 2 Velocity', linewidth=2)
        axes[1, 1].set_xlabel('Time (s)')
        axes[1, 1].set_ylabel('Joint 2 Velocity (rad/s)')
        axes[1, 1].legend()
        axes[1, 1].grid(True)
        axes[1, 1].set_title('Joint 2 Velocity')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"2_arm_joints.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Arm joint plot saved to: {full_path}")
        
        return fig
    
    def plot_mpc_performance(self, data, metadata, save_path=None):
        """Plot MPC performance charts"""
        time_data = data['time']
        mpc_times = data['mpc_solve_time'] * 1000  # Convert to milliseconds
        mpc_costs = data['mpc_cost']
        
        fig, axes = plt.subplots(2, 1, figsize=(10, 8))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - MPC Performance Analysis', fontsize=16)
        
        # MPC solve time
        axes[0].plot(time_data, mpc_times, 'b-', linewidth=2)
        axes[0].set_xlabel('Time (s)')
        axes[0].set_ylabel('MPC Solve Time (ms)')
        axes[0].grid(True)
        axes[0].set_title(f'MPC Solve Time (Average: {np.mean(mpc_times):.2f}ms, Max: {np.max(mpc_times):.2f}ms)')
        
        # Add solve time statistics
        axes[0].axhline(y=np.mean(mpc_times), color='r', linestyle='--', alpha=0.7, label=f'Average: {np.mean(mpc_times):.2f}ms')
        axes[0].axhline(y=np.percentile(mpc_times, 95), color='orange', linestyle='--', alpha=0.7, label=f'95th percentile: {np.percentile(mpc_times, 95):.2f}ms')
        axes[0].legend()
        
        # MPC cost function
        axes[1].plot(time_data, mpc_costs, 'r-', linewidth=2)
        axes[1].set_xlabel('Time (s)')
        axes[1].set_ylabel('MPC Cost')
        axes[1].grid(True)
        axes[1].set_title(f'MPC Cost Function (Average: {np.mean(mpc_costs):.3f}, Final: {mpc_costs[-1]:.3f})')
        
        plt.tight_layout()
        
        if save_path:
            filename = f"3_mpc_performance.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"MPC performance plot saved to: {full_path}")
        
        return fig
    
    def plot_3d_trajectory(self, data, metadata, save_path=None):
        """Plot 3D trajectory"""
        position_data = data['position']
        ref_position_data = data['reference_position']
        
        fig = plt.figure(figsize=(12, 8))
        ax = fig.add_subplot(111, projection='3d')
        
        # Plot trajectories
        ax.plot(position_data[:, 0], position_data[:, 1], position_data[:, 2], 
                'b-', label='Actual Trajectory', linewidth=3, alpha=0.8)
        ax.plot(ref_position_data[:, 0], ref_position_data[:, 1], ref_position_data[:, 2], 
                'r--', label='Reference Trajectory', linewidth=3, alpha=0.8)
        
        # Mark start and end points
        ax.scatter(position_data[0, 0], position_data[0, 1], position_data[0, 2], 
                  color='green', s=100, label='Start')
        ax.scatter(position_data[-1, 0], position_data[-1, 1], position_data[-1, 2], 
                  color='red', s=100, label='End')
        
        ax.set_xlabel('X Position (m)')
        ax.set_ylabel('Y Position (m)')
        ax.set_zlabel('Z Position (m)')
        ax.set_ylim(-1.0, 1.0)
        ax.legend()
        
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        ax.set_title(f'{robot_name} - {traj_name} 3D Trajectory')
        
        if save_path:
            filename = f"4_trajectory_3d.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"3D trajectory plot saved to: {full_path}")
        
        return fig
    
    def plot_tracking_errors(self, data, metadata, save_path=None):
        """Plot tracking error analysis"""
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        # Calculate errors
        pos_error = np.linalg.norm(position_data - ref_position_data, axis=1)
        vel_error = np.linalg.norm(velocity_data - ref_velocity_data, axis=1)
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Tracking Error Analysis', fontsize=16)
        
        # Position error time series
        axes[0, 0].plot(time_data, pos_error, 'b-', linewidth=2)
        axes[0, 0].set_xlabel('Time (s)')
        axes[0, 0].set_ylabel('Position Error (m)')
        axes[0, 0].grid(True)
        axes[0, 0].set_title(f'Position Tracking Error (RMS: {np.sqrt(np.mean(pos_error**2)):.4f}m)')
        
        # Velocity error time series
        axes[0, 1].plot(time_data, vel_error, 'r-', linewidth=2)
        axes[0, 1].set_xlabel('Time (s)')
        axes[0, 1].set_ylabel('Velocity Error (m/s)')
        axes[0, 1].grid(True)
        axes[0, 1].set_title(f'Velocity Tracking Error (RMS: {np.sqrt(np.mean(vel_error**2)):.4f}m/s)')
        
        # Position error histogram
        axes[1, 0].hist(pos_error, bins=30, alpha=0.7, color='blue', edgecolor='black')
        axes[1, 0].axvline(np.mean(pos_error), color='red', linestyle='--', 
                          label=f'Mean: {np.mean(pos_error):.4f}m')
        axes[1, 0].axvline(np.percentile(pos_error, 95), color='orange', linestyle='--', 
                          label=f'95th percentile: {np.percentile(pos_error, 95):.4f}m')
        axes[1, 0].set_xlabel('Position Error (m)')
        axes[1, 0].set_ylabel('Frequency')
        axes[1, 0].set_title('Position Error Distribution')
        axes[1, 0].legend()
        axes[1, 0].grid(True, alpha=0.3)
        
        # Velocity error histogram
        axes[1, 1].hist(vel_error, bins=30, alpha=0.7, color='red', edgecolor='black')
        axes[1, 1].axvline(np.mean(vel_error), color='blue', linestyle='--', 
                          label=f'Mean: {np.mean(vel_error):.4f}m/s')
        axes[1, 1].axvline(np.percentile(vel_error, 95), color='orange', linestyle='--', 
                          label=f'95th percentile: {np.percentile(vel_error, 95):.4f}m/s')
        axes[1, 1].set_xlabel('Velocity Error (m/s)')
        axes[1, 1].set_ylabel('Frequency')
        axes[1, 1].set_title('Velocity Error Distribution')
        axes[1, 1].legend()
        axes[1, 1].grid(True, alpha=0.3)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"5_tracking_error.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Tracking error analysis plot saved to: {full_path}")
        
        return fig
    
    def plot_control_commands(self, data, metadata, save_path=None):
        """Plot control command charts"""
        time_data = data['time']
        
        fig, axes = plt.subplots(2, 2, figsize=(14, 10))
        robot_name = metadata.get('robot_name', 'Unknown')
        traj_name = metadata.get('trajectory_name', 'Unknown')
        fig.suptitle(f'{robot_name} - Control Command Analysis', fontsize=16)
        
        # MPC control commands (forces and moments)
        if 'mpc_control_ft' in data and len(data['mpc_control_ft']) > 0:
            mpc_control = np.array(data['mpc_control_ft'])
            
            # Force commands
            axes[0, 0].plot(time_data, mpc_control[:, 0], 'r-', label='Fx', linewidth=2)
            axes[0, 0].plot(time_data, mpc_control[:, 1], 'g-', label='Fy', linewidth=2)
            axes[0, 0].plot(time_data, mpc_control[:, 2], 'b-', label='Fz', linewidth=2)
            axes[0, 0].set_xlabel('Time (s)')
            axes[0, 0].set_ylabel('Force (N)')
            axes[0, 0].set_title('MPC Force Commands')
            axes[0, 0].legend()
            axes[0, 0].grid(True)
            
            # Moment commands
            axes[0, 1].plot(time_data, mpc_control[:, 3], 'r-', label='Mx', linewidth=2)
            axes[0, 1].plot(time_data, mpc_control[:, 4], 'g-', label='My', linewidth=2)
            axes[0, 1].plot(time_data, mpc_control[:, 5], 'b-', label='Mz', linewidth=2)
            axes[0, 1].set_xlabel('Time (s)')
            axes[0, 1].set_ylabel('Moment (N·m)')
            axes[0, 1].set_title('MPC Moment Commands')
            axes[0, 1].legend()
            axes[0, 1].grid(True)
        
        # L1 adaptive control commands
        if 'l1_control_ad' in data and len(data['l1_control_ad']) > 0:
            l1_control = np.array(data['l1_control_ad'])
            
            # L1 adaptive force commands
            axes[1, 0].plot(time_data, l1_control[:, 0], 'r-', label='L1 Fx', linewidth=2)
            axes[1, 0].plot(time_data, l1_control[:, 1], 'g-', label='L1 Fy', linewidth=2)
            axes[1, 0].plot(time_data, l1_control[:, 2], 'b-', label='L1 Fz', linewidth=2)
            axes[1, 0].set_xlabel('Time (s)')
            axes[1, 0].set_ylabel('L1 Adaptive Force (N)')
            axes[1, 0].set_title('L1 Adaptive Force Commands')
            axes[1, 0].legend()
            axes[1, 0].grid(True)
            
            # L1 adaptive moment commands
            axes[1, 1].plot(time_data, l1_control[:, 3], 'r-', label='L1 Mx', linewidth=2)
            axes[1, 1].plot(time_data, l1_control[:, 4], 'g-', label='L1 My', linewidth=2)
            axes[1, 1].plot(time_data, l1_control[:, 5], 'b-', label='L1 Mz', linewidth=2)
            axes[1, 1].set_xlabel('Time (s)')
            axes[1, 1].set_ylabel('L1 Adaptive Moment (N·m)')
            axes[1, 1].set_title('L1 Adaptive Moment Commands')
            axes[1, 1].legend()
            axes[1, 1].grid(True)
        
        plt.tight_layout()
        
        if save_path:
            filename = f"6_control_commands.png"
            full_path = os.path.join(save_path, filename)
            plt.savefig(full_path, dpi=300, bbox_inches='tight')
            print(f"Control command plot saved to: {full_path}")
        
        return fig
    
    def generate_comprehensive_report(self, data, metadata, save_path=None):
        """Generate comprehensive analysis report"""
        print("\n" + "="*60)
        print("TRAJECTORY EXECUTION COMPREHENSIVE ANALYSIS REPORT")
        print("="*60)
        
        # Basic information
        print(f"Robot name: {metadata.get('robot_name', 'Unknown')}")
        print(f"Trajectory name: {metadata.get('trajectory_name', 'Unknown')}")
        print(f"Control mode: {metadata.get('control_mode', 'Unknown')}")
        print(f"Arm enabled: {metadata.get('arm_enabled', False)}")
        print(f"Recording duration: {metadata.get('recording_duration', 0):.2f} seconds")
        print(f"Sampling frequency: {metadata.get('control_rate', 0)} Hz")
        print(f"Number of data points: {metadata.get('num_samples', 0)}")
        
        # Performance analysis
        time_data = data['time']
        position_data = data['position']
        velocity_data = data['velocity']
        ref_position_data = data['reference_position']
        ref_velocity_data = data['reference_velocity']
        
        # Calculate tracking errors
        pos_error = np.linalg.norm(position_data - ref_position_data, axis=1)
        vel_error = np.linalg.norm(velocity_data - ref_velocity_data, axis=1)
        
        print(f"\nPosition tracking performance:")
        print(f"  Mean error: {np.mean(pos_error):.4f} m")
        print(f"  Max error: {np.max(pos_error):.4f} m")
        print(f"  RMS error: {np.sqrt(np.mean(pos_error**2)):.4f} m")
        print(f"  Standard deviation: {np.std(pos_error):.4f} m")
        
        print(f"\nVelocity tracking performance:")
        print(f"  Mean error: {np.mean(vel_error):.4f} m/s")
        print(f"  Max error: {np.max(vel_error):.4f} m/s")
        print(f"  RMS error: {np.sqrt(np.mean(vel_error**2)):.4f} m/s")
        print(f"  Standard deviation: {np.std(vel_error):.4f} m/s")
        
        # MPC performance
        mpc_times = data['mpc_solve_time'] * 1000
        mpc_costs = data['mpc_cost']
        
        print(f"\nMPC controller performance:")
        print(f"  Mean solve time: {np.mean(mpc_times):.2f} ms")
        print(f"  Max solve time: {np.max(mpc_times):.2f} ms")
        print(f"  95th percentile solve time: {np.percentile(mpc_times, 95):.2f} ms")
        print(f"  Mean cost: {np.mean(mpc_costs):.3f}")
        print(f"  Final cost: {mpc_costs[-1]:.3f}")
        
        # Arm performance (if data available)
        if 'arm_joint_positions' in data and len(data['arm_joint_positions']) > 0:
            arm_pos_data = data['arm_joint_positions']
            arm_vel_data = data['arm_joint_velocities']
            ref_arm_pos_data = data['reference_arm_positions']
            
            arm_pos_error = np.linalg.norm(arm_pos_data - ref_arm_pos_data, axis=1)
            
            print(f"\nArm tracking performance:")
            print(f"  Mean joint position error: {np.mean(arm_pos_error):.4f} rad")
            print(f"  Max joint position error: {np.max(arm_pos_error):.4f} rad")
            print(f"  Joint 1 mean velocity: {np.mean(np.abs(arm_vel_data[:, 0])):.3f} rad/s")
            print(f"  Joint 2 mean velocity: {np.mean(np.abs(arm_vel_data[:, 1])):.3f} rad/s")
        
        # Save report to file
        if save_path:
            robot_name = metadata.get('robot_name', 'Unknown')
            traj_name = metadata.get('trajectory_name', 'Unknown')
            report_filename = f"{robot_name}_{traj_name}_analysis_report_{time.strftime('%Y%m%d_%H%M%S')}.txt"
            report_path = os.path.join(save_path, report_filename)
            
            with open(report_path, 'w', encoding='utf-8') as f:
                f.write("TRAJECTORY EXECUTION COMPREHENSIVE ANALYSIS REPORT\n")
                f.write("="*60 + "\n\n")
                f.write(f"Generated at: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")
                
                f.write("Basic Information:\n")
                f.write(f"  Robot name: {metadata.get('robot_name', 'Unknown')}\n")
                f.write(f"  Trajectory name: {metadata.get('trajectory_name', 'Unknown')}\n")
                f.write(f"  Control mode: {metadata.get('control_mode', 'Unknown')}\n")
                f.write(f"  Arm enabled: {metadata.get('arm_enabled', False)}\n")
                f.write(f"  Recording duration: {metadata.get('recording_duration', 0):.2f} seconds\n")
                f.write(f"  Sampling frequency: {metadata.get('control_rate', 0)} Hz\n")
                f.write(f"  Number of data points: {metadata.get('num_samples', 0)}\n\n")
                
                f.write("Position tracking performance:\n")
                f.write(f"  Mean error: {np.mean(pos_error):.4f} m\n")
                f.write(f"  Max error: {np.max(pos_error):.4f} m\n")
                f.write(f"  RMS error: {np.sqrt(np.mean(pos_error**2)):.4f} m\n")
                f.write(f"  Standard deviation: {np.std(pos_error):.4f} m\n\n")
                
                f.write("Velocity tracking performance:\n")
                f.write(f"  Mean error: {np.mean(vel_error):.4f} m/s\n")
                f.write(f"  Max error: {np.max(vel_error):.4f} m/s\n")
                f.write(f"  RMS error: {np.sqrt(np.mean(vel_error**2)):.4f} m/s\n")
                f.write(f"  Standard deviation: {np.std(vel_error):.4f} m/s\n\n")
                
                f.write("MPC controller performance:\n")
                f.write(f"  Mean solve time: {np.mean(mpc_times):.2f} ms\n")
                f.write(f"  Max solve time: {np.max(mpc_times):.2f} ms\n")
                f.write(f"  95th percentile solve time: {np.percentile(mpc_times, 95):.2f} ms\n")
                f.write(f"  Mean cost: {np.mean(mpc_costs):.3f}\n")
                f.write(f"  Final cost: {mpc_costs[-1]:.3f}\n\n")
            
            print(f"\nAnalysis report saved to: {report_path}")
    
    def find_latest_file(self, robot_name=None):
        """Find the latest data file"""
        if not os.path.exists(self.base_results_dir):
            print(f"Base results directory {self.base_results_dir} does not exist!")
            return None
        
        if robot_name:
            pattern = os.path.join(self.base_results_dir, "*", f"{robot_name}_*_trajectory_data*.npz")
        else:
            pattern = os.path.join(self.base_results_dir, "*", "*_trajectory_data.npz")
        
        files = glob.glob(pattern)
        
        if not files:
            print("No data files found")
            return None
        
        # Sort by modification time, newest first
        files.sort(key=os.path.getmtime, reverse=True)
        latest_file = files[0]
        
        return latest_file
    
    def find_all_files(self, robot_name=None):
        """Find all data files"""
        if not os.path.exists(self.results_dir):
            return []
        
        if robot_name:
            pattern = os.path.join(self.results_dir, f"{robot_name}_*_trajectory_data_*.npz")
        else:
            pattern = os.path.join(self.results_dir, "*_trajectory_data_*.npz")
        
        files = glob.glob(pattern)
        files.sort(key=os.path.getmtime, reverse=True)
        return files
    
    def process_single_file(self, filepath, show_plots=True, save_plots=True):
        """Process single data file"""
        print(f"\nProcessing file: {filepath}")
        
        # Update self.results_dir based on the folder containing the found file
        file_dir = os.path.dirname(filepath)
        self.results_dir = file_dir
        print(f"Updated results directory to: {self.results_dir}")
        
        # Load data
        data, metadata = self.load_data(filepath)
        if data is None:
            return
        
        save_path = self.results_dir if save_plots else None
        
        # Generate all plots
        print("\nGenerating plots...")
        
        figures = []
        
        # Position velocity tracking
        fig1 = self.plot_position_velocity_tracking(data, metadata, save_path)
        figures.append(fig1)
        
        # Arm joints (if data available)
        fig2 = self.plot_arm_joints(data, metadata, save_path)
        if fig2:
            figures.append(fig2)
        
        # MPC performance
        fig3 = self.plot_mpc_performance(data, metadata, save_path)
        figures.append(fig3)
        
        # 3D trajectory
        fig4 = self.plot_3d_trajectory(data, metadata, save_path)
        figures.append(fig4)
        
        # Tracking error analysis
        fig5 = self.plot_tracking_errors(data, metadata, save_path)
        figures.append(fig5)
        
        # Control commands
        fig6 = self.plot_control_commands(data, metadata, save_path)
        figures.append(fig6)
        
        # Generate comprehensive report
        self.generate_comprehensive_report(data, metadata, save_path)
        
        if show_plots:
            plt.show()
        else:
            # Close all figures to free memory
            for fig in figures:
                if fig:
                    plt.close(fig)
    
    def process_batch(self, robot_name=None, show_plots=False):
        """Batch process all data files"""
        files = self.find_all_files(robot_name)
        
        if not files:
            print("No data files found")
            return
        
        print(f"Found {len(files)} data files, starting batch processing...")
        
        for i, filepath in enumerate(files):
            print(f"\n[{i+1}/{len(files)}] ", end="")
            self.process_single_file(filepath, show_plots=False, save_plots=True)
        
        print(f"\nBatch processing complete! Processed {len(files)} files")

def main():
    parser = argparse.ArgumentParser(description='Trajectory data visualization tool')
    parser.add_argument('--file', '-f', type=str, help='Specify data file path')
    parser.add_argument('--robot', '-r', type=str, help='Specify robot name')
    parser.add_argument('--batch', '-b', action='store_true', help='Batch process all files')
    parser.add_argument('--no-show', action='store_true', help='Do not show plots, only save')
    parser.add_argument('--compare', '-c', nargs='+', help='Compare multiple data files')
    
    args = parser.parse_args()
    
    plotter = TrajectoryDataPlotter()
    
    if args.compare:
        # Comparison mode
        print("Comparison analysis mode - feature to be implemented")
        # TODO: Implement comparison functionality
    elif args.batch:
        # Batch processing mode
        plotter.process_batch(args.robot, show_plots=not args.no_show)
    elif args.file:
        # Specified file mode
        if not os.path.exists(args.file):
            print(f"File does not exist: {args.file}")
            return
        plotter.process_single_file(args.file, show_plots=not args.no_show)
    else:
        # Default: process latest file
        latest_file = plotter.find_latest_file(args.robot)
        if latest_file:
            print(f"Processing latest file: {os.path.basename(latest_file)}")
            plotter.process_single_file(latest_file, show_plots=not args.no_show)
        else:
            print("No data files found")
            print("\nUsage instructions:")
            print("1. Basic usage (process latest file): python3 plot_trajectory_data.py")
            print("2. Specify file: python3 plot_trajectory_data.py --file path/to/data.npz")
            print("3. Batch processing: python3 plot_trajectory_data.py --batch")
            print("4. Specify robot: python3 plot_trajectory_data.py --robot s500_uam")
            print("5. No display mode: python3 plot_trajectory_data.py --no-show")

if __name__ == "__main__":
    main()
